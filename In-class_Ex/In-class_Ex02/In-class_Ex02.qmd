---
title: "In-class Exercise 2"
execute:
  warning: false
  echo: true
  eval: true
date: "`r Sys.Date()`"
---

<!-- echo and eval = true will ensure that it all runs globally unless specified otherwise-->

<!-- to hide table of contents, use toc: false; to increase depth use toc-depth: [number] -->

<!-- format: html: code-fold: true code-summary: "Show the code" -->

These are notes and exercises for week 2.

## Packages used

The following R packages will be used in this class:

-   `arrow`: allows for handling of databases and data conversion. For this exercise specifically, it allows us to read Parquet files

-   `lubridate`: part of tidyverse, but a later part so it requires a separate download, allows for working with dates and times

-   `tidyverse`

-   `tmap`

-   `sf`

```{r}
pacman::p_load(arrow, lubridate, tidyverse, tmap, sf)
```

::: callout-important
## New formatting trick

Took a peek at prof's code during the class, found out and tried using call out notes
:::

## Importing data for exercise

For this exercise, we are using some Grab data that Prof Kam has provided for us.

Because the data is a PARAQUET file type, we will be using *read_paraquet* from the `arrow` package. This will be saved as `df`.

```{r}
#| eval: false
df <- read_parquet("data/GrabPosisi/part-00000.parquet")
```
```{r}
#| code-fold: true
df
```

::: callout-tip
For ease of calling, we can rename the file to something easier to use
:::

::: callout-note
It is possible to go back to the root instead for the data, but this is messy
:::

```{r}
#| code-fold: true
#| eval: false

df1 <- read_parquet("../../data/GrabPosisi/part-00000.parquet")
```

<!-- for .gitignore, any file that is NAMED data will not be pushed to github -->

### Converting the data type of *pingtimestamp* to date-time

```{r}
#| eval: false
df$pingtimestamp <- as_datetime(df$pingtimestamp)
```

::: callout-tip
By using the \$, it allows us to call and overwrite the df directly
:::

Now to save the reformatted df into a new rds file.

```{r}
#| eval: false
write_rds(df, "data/rds/part0.rds")
```

## Extracting trip starting locations

Now, we extract the trips origin locations, derive 3 new columns for weekday, starting hour and day of month and name the output tibble data.frame *origin_df*

```{r}
#| eval: false
origin_df <- df %>%
  group_by(trj_id) %>%
  arrange(pingtimestamp) %>%
  filter(row_number()==1) %>%
  mutate(weekday = wday(pingtimestamp,
                        label = TRUE,
                        abbr = TRUE),
         start_hr = factor(hour(pingtimestamp)),
         day = factor(mday(pingtimestamp)))
```

<!-- group by trj_id, sort time stamp in ascending order, filter out for the first time stamp of each trj_id then mutate. Use factor to get ordinal scale data -->

<!-- label means it actually labels it by the days of the week, while abbr will abbreviate the names -->

::: callout-important
`wday`, `hour` and `mday` are from *lubridate* package, while`arrange` is from *dplyr*
:::

## Extracting trip ending locations

Now, we are extracting the destination locations.

```{r}
#| eval: false
dest_df <- df %>%
  group_by(trj_id) %>%
  arrange(pingtimestamp) %>%
  filter(row_number()==n()) %>%
  mutate(weekday = wday(pingtimestamp,
                        label = TRUE,
                        abbr = TRUE),
         start_hr = factor(hour(pingtimestamp)),
         day = factor(mday(pingtimestamp)))
```

::: callout-important
An alternate way to arrange is `arrange(desc(pingtimestamp)) %>% filter(row_number() == 1)`
:::

Remember to write it out as rds to save space.

```{r}
#| eval: false
write_rds(origin_df, "data/rds/origin_df.rds")
write_rds(dest_df, "data/rds/dest_df.rds")
```

**rds** will save all object classes as native, which means that it will save all the special labels and abbreviations as well. This allows us to directly use the data without having to reformat it again.

## Import data, but this time as rds

```{r}
origin_df <- read_rds("data/rds/origin_df.rds")
dest_df <- read_rds("data/rds/dest_df.rds")
```

::: callout-important
After everything above has been run and saved, you can use #\| eval:false to prevent the code chunk from running
:::

## DIY: to be done at home

Import the 2019 master plan planning subzone and map the start and end locations onto the map.

All of the dots should be within the boundaries of the Singapore map
