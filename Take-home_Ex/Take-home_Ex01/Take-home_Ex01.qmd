---
title: "Take Home Exercise 1: Application of Spatial Point Patterns Analysis"

execute:
  warning: false
output:
  html_document:
    toc: true
    number_sections: true
    toc_float:
      collapsed: false
date: "`r Sys.Date()`"
---

# Project overview

In this study, we apply appropriate spatial point patterns analysis methods to discover the geographical and spatio-temporal distribution of Grab hailing services locations in Singapore and describe the spatial patterns revealed by kernel density maps.

# Installing R packages

For this exercise, I will be using the following packages:

-   sf

-   tidyverse

-   tmap

-   spatstat

-   maptools

-   raster

-   arrow

-   lubridate

-   readr (for saving transformed data sets as rds)

```{r}
pacman::p_load(sf, tidyverse, tmap, spatstat, maptools, raster, arrow, lubridate, readr)
```

# Data Import and initial data transformation

For this section, after all data sets have been transformed, they will be saved in the `rds` format for easier use in the rest of the exercise.

## Aspatial data

### Grab Posisi data

First, the data needs to be imported into RStudio. In this exercise, we will need to import all of the data in order to observe the temporal distribution.

```{r}
#| eval: false
df <- read_parquet(file="data/aspatial/GrabPosisi/part-00000.parquet")
df1 <- read_parquet(file="data/aspatial/GrabPosisi/part-00001.parquet")
df2 <- read_parquet(file="data/aspatial/GrabPosisi/part-00002.parquet")
df3 <- read_parquet(file="data/aspatial/GrabPosisi/part-00003.parquet")
df4 <- read_parquet(file="data/aspatial/GrabPosisi/part-00004.parquet")
df5 <- read_parquet(file="data/aspatial/GrabPosisi/part-00005.parquet")
df6 <- read_parquet(file="data/aspatial/GrabPosisi/part-00006.parquet")
df7 <- read_parquet(file="data/aspatial/GrabPosisi/part-00007.parquet")
df8 <- read_parquet(file="data/aspatial/GrabPosisi/part-00008.parquet")
df9 <- read_parquet(file="data/aspatial/GrabPosisi/part-00009.parquet")
```

#### Combining the data
All of the data covers 2 weeks of Grab rides, but they are jumbled up. In order to accurately extract the origin and destination points, we need to combine everything into a singular data frame.

```{r}
#| eval: false


all_grab <- df %>%
  full_join(df1) %>%
  full_join(df2) %>%
  full_join(df3) %>%
  full_join(df4) %>%
  full_join(df5) %>%
  full_join(df6) %>%
  full_join(df7) %>%
  full_join(df8) %>%
  full_join(df9)
```

#### Data handling: Converting the data type of *pingtimestamp* to date-time

Grab marks the date-time of each data point as a pingtimestamp. As a result, we will need to transform the data type to date-time using lubridate.

```{r}
#| eval: false
all_grab$pingtimestamp <- as_datetime(all_grab$pingtimestamp)
```

#### Data handling: Extracting trip origins

Now, we extract the trip origin locations and derive 3 new columns for weekday, starting hour and day of month into a new data frame. The origin locations are derived by grouping trips according to their `trj_id`, arranging by the date-time and filtering for the first item in each group.

```{r}
#| eval: false

origin_df <- all_grab %>%
  group_by(trj_id) %>%
  arrange(pingtimestamp) %>%
  filter(row_number()==1) %>%
  mutate(weekday = wday(pingtimestamp,
                        label = TRUE,
                        abbr = TRUE),
         start_hr = factor(hour(pingtimestamp)),
         day = factor(mday(pingtimestamp)))

```

#### Data handling: Extracting destinations

To extract trip destinations, we use a similar code as above except we filter to take the nth item out of n items in a group.

```{r}
#| eval: false


dest_df <- all_grab %>%
  group_by(trj_id) %>%
  arrange(pingtimestamp) %>%
  filter(row_number()==n()) %>%
  mutate(weekday = wday(pingtimestamp,
                        label = TRUE,
                        abbr = TRUE),
         start_hr = factor(hour(pingtimestamp)),
         day = factor(mday(pingtimestamp)))
```

#### Writing data as rds

With the data transformation done, we can now write it out as an rds for future use.

```{r}
#| eval: false

write_rds(origin_df, "data/rds/grab_origins.rds")
write_rds(dest_df, "data/rds/grab_dest.rds")
```

## Geospatial data

### Singapore Coastal outline (excluding islands)

This layer is derived from the Master Plan 2019 Subzone Boundary (No Sea) from data.gov. First, it needs to be imported into rstudio using *st_read()*

```{r}
#| eval: false

mpsz_sf <- st_read(dsn = "data/geospatial", 
                layer = "MPSZ-2019")
```

From the summary, it can be seen that the layer is projected to WGS84. To continue, there is the need to reproject the polygons to the correct CRS SVY21.

```{r}
#| eval: false

mpsz3414_sf <- st_transform(mpsz_sf, 3414)
```

Now, we can plot the map and view the data.

```{r}
#| eval: false
plot(mpsz3414_sf["SUBZONE_N"])
```

There are some islands in the map that lack bridges for Grab drivers to reach, such as Coney Island. However, there are other relevant islands such as Sentosa that need to be kept.

From research, Grab drivers can be observed to be able to enter [Sentosa](https://www.grab.com/sg/sentosaentry/) and [Jurong Island](https://www.firstlane.com.sg/grab-jurong-island-pass/) to pick up and drop off passengers at the current moment. However, the Jurong Island polygon in `mpsz3414_sf` is combined with another island Bukom. Furthermore, Grab drivers are only allowed onto the island if they have a security pass, resulting in few drivers entering and exiting the island. Therefore, I am choosing to remove Jurong Island and Bukom from the map.

Hence, the islands that need to be excluded from the map are:

-   Coney Island

-   Southern Group

-   North-Eastern islands (including [Pulau Ubin](https://wansubinjournal.blogspot.com/p/ubin-map.html): Grab drivers can only pick up and drop off passengers at the ferry terminal)

-   Sudong

-   Semakau

-   Jurong Island and Bukom

To remove these, I've chosen to filter them out by name. This is because Sentosa and Jurong Island are also labelled as "islands" and would otherwise be caught.

```{r}
#| eval: false
main_island <- mpsz3414_sf %>%
              filter(SUBZONE_N !="CONEY ISLAND") %>%
              filter(SUBZONE_N != "NORTH-EASTERN ISLANDS") %>%
              filter(SUBZONE_N != "SOUTHERN GROUP") %>%
              filter(SUBZONE_N != "SUDONG") %>%
              filter(SUBZONE_N != "SEMAKAU") %>%
              filter(SUBZONE_N != "SUDONG") %>%
              filter(SUBZONE_N != "JURONG ISLAND AND BUKOM")

plot(main_island["SUBZONE_N"])
```

Now, we can use *st_union* to get the outline of Singapore.

```{r}
#| eval: false

plot(st_union(main_island))
```

#### Writing data as rds

With this, we can now save the data in the rds format.

```{r}
#| eval: false

write_rds(main_island, "data/rds/islandOutline.rds")
```

### Singapore road network

In order to conduct Network Kernel Density Estimation (NKDE), we will need a road network to map points onto. For Singapore's road network, we can get data from OpenStreetMap via [Geofabrik](https://download.geofabrik.de/). From the documentation that comes with the download, we know that the road network is found in the `gis_osm_roads_free_1` shape file.

```{r}
#| eval: false

roads_all <- st_read(dsn = "data/geospatial/openstreetmap", 
                layer = "gis_osm_roads_free_1")
```

This data is also not projected to SVY21, which is something we will have to fix.

```{r}
#| eval: false

roads_all <- st_transform(roads_all, 3414)
```

One issue currently is that the data includes all roads from [Singapore, Malaysia and Brunei](https://download.geofabrik.de/asia.html). We only want the road network for Singapore. In order to extract this, we can use *st_intersection* to filter for roads within Singapore based on the `CoastalOutline` layer (as imported from rds)

```{r}
#| eval: false

sg_roads <- st_intersection(roads_all, CoastalOutline)
```

Due to the size of the data, we will later be narrowing the scope of our investigation for NKDE to certain subzones. For now, I will save the current road network into an rds.

```{r}
#| eval: false

write_rds(sg_roads, "data/rds/sgroads.rds")
```

# Final import of data

```{r}
origin_all_df <- read_rds("data/rds/grab_origins.rds")
dest_all_df <- read_rds("data/rds/grab_dest.rds")
CoastalOutline <- read_rds("data/rds/islandOutline.rds")
sg_roads <- read_rds("data/rds/sgroads.rds")
```

# Data wrangling: origins

## Analysis of origins

First, lets look at the distribution of origins over time using `ggplot`.

```{r}
ggplot(data = origin_all_df,
       aes(x=weekday)) +
geom_bar()
```

As seen above, the data is evenly distributed across all days of the week.

### ppp object transformation

In order to conduct Kernel Density Estimation (KDE), we need to transform our layers into a ppp object. Before we begin that process, we will need to transform `origin_all_df` into an sf object using *st_as_sf()*.

::: callout-important
For the "crs" argument of *st_as_sf()*, we need to provide it with a geodetic CRS and not a projected CRS. To transform the CRS, we can pipe the output into an *st_transform()* argument.
:::

```{r}
origins_sf <- st_as_sf(origin_all_df, 
                       coords = c("rawlng", "rawlat"),
                       crs=4326) %>%
  st_transform(crs = 3414)
```

Now, we can transform all relevant data frames into a ppp object (via transforming to Spatial/\*, SpatialPoints and then ppp objects), which we can inspect using the *summary* function.

```{r}
origin_spatial <- as_Spatial(origins_sf)
origin_sp <- as(origin_spatial, "SpatialPoints")
origin_ppp <- as(origin_sp, "ppp")

summary(origin_ppp)
```

### Duplicate data handling

Now, we need to check for duplicated data.

```{r}
any(duplicated(origin_ppp))
```

If we want to know how many locations have more than one point event, we can use the following:

```{r}
sum(multiplicity(origin_ppp) > 1)
```

As we can see, there is no duplicate data in the ppp object.

### Creating owin object

Next, we need to confine the analysis with a geographical area like Singapore boundary. If a study area is not defined and confined, the data points will assume it can occur within blank spaces (because technically it will spread out at random).

```{r}
CoastalOutline <- st_union(CoastalOutline)
sg_owin <- as.owin(CoastalOutline)
plot(sg_owin)
```

```{r}
summary(sg_owin)
```

With that, we can finally plot the point data onto the map.

```{r}
originSG = origin_ppp[sg_owin]

plot(originSG)
```

# Kernel Density Estimation: origins

## Rescaling values

Before we can conduct KDE analysis, we first need to rescale the unit of measurement in `originSG` from metres (the unit of measurement in SVY21) to kilometres (to avoid small numbers).

```{r}
originSG_km <- rescale(originSG, 1000, "km")
```

## Working with different automatic bandwidth selection methods

There are 4 different automatic bandwidth selection method that we can choose: *bw.diggle, bw.CvL, bw.scott* and *bw.ppl*. For this exercise, we are using *bw.diggle*, or the radius selection method. We can plot all four to see which may give us better results.
```{r}
kde_origins_dig <- density(originSG_km,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian") 

kde_origins_ppl <- density(originSG_km, 
                               sigma=bw.ppl, 
                               edge=TRUE,
                               kernel="gaussian")

kde_origins_cvl <- density(originSG_km,
                              sigma=bw.CvL,
                              edge=TRUE,
                            kernel="gaussian") 

kde_origins_scott <- density(originSG_km,
                              sigma=bw.scott,
                              edge=TRUE,
                            kernel="gaussian") 

par(mfrow=c(2,2))
plot(kde_origins_dig, main = "bw.diggle")
plot(kde_origins_ppl, main = "bw.ppl")
plot(kde_origins_cvl, main = "bw.cvl")
plot(kde_origins_scott, main = "bw.scott")
```

We can retrieve the bandwidth used to compute the KDE layer as well.

```{r}
bw.diggle(originSG)
bw.ppl(originSG)
bw.CvL(originSG)
bw.scott(originSG)
```

As seen, bw.ppl and bw.diggle appears to give relatively similar map results which highlight a single tight cluster in the east and include up to a thousand origin points. Meanwhile, bw.cvl and bw.scott appear to use tighter radii, with bw.scott being able to better show hotspots compared to how spread out bw.cvl looks. Hence, for the rest of this exercise, we will be using bw.scott.

## Working with different kernel methods

By default, the kernel method used in density.ppp() is gaussian. But there are three other options, namely: Epanechnikov, Quartic and Dics. We can test each of these to see which kernel method provides a tighter grouping.

```{r}
par(mfrow=c(2,2))
plot(density(originSG_km, 
             sigma=bw.scott, 
             edge=TRUE, 
             kernel="gaussian"), 
     main="Gaussian")

plot(density(originSG_km, 
             sigma=bw.scott, 
             edge=TRUE, 
             kernel="epanechnikov"), 
     main="Epanechnikov")

plot(density(originSG_km, 
             sigma=bw.scott, 
             edge=TRUE, 
             kernel="quartic"), 
     main="Quartic")

plot(density(originSG_km, 
             sigma=bw.scott, 
             edge=TRUE, 
             kernel="disc"), 
     main="Disc")
```
For this exercise, disc and quartic appear to provide us with tighter values. Hence, we will be using Disc.

# Fixed and Adaptive KDE bandwidths
For a fixed bandwidth, we will be fixing the radius at 600m.
```{r}
kde_originSG_600 <- density(originSG_km, sigma=0.6, edge=TRUE, kernel="disc")
plot(kde_originSG_600)
```
Typically, a fixed bandwidth method is very sensitive to highly skewed distribution of spatial point patterns over geographical units. To get around this, we can use an adaptive bandwidth instead.

```{r}
kde_originSG_adaptive <- adaptive.density(originSG_km, method="kernel")
plot(kde_originSG_adaptive)
```

We can compare the fixed and adaptive kernel density estimation outputs by using the code chunk below.

```{r}
par(mfrow=c(1,2))
plot(kde_originSG_600, main = "Fixed bandwidth")
plot(kde_originSG_adaptive, main = "Adaptive bandwidth")
```

## Conversion to raster via grid object
In order to fully visualise KDE in tmap, we would need to transform it into raster data. Before that, we need to convert it into a grid object

```{r}
gridded_kde_origins_bw <- as.SpatialGridDataFrame.im(kde_originSG_600)
spplot(gridded_kde_origins_bw)
```
Now, we can convert it to raster data.
```{r}
kde_originsSG_bw_raster <- raster(gridded_kde_origins_bw)
```
Note that there is no CRS to this data, so we will need to assign it on our own
```{r}
projection(kde_originsSG_bw_raster) <- CRS("+init=EPSG:3414")
kde_originsSG_bw_raster
```
## Visualising KDE (tmap)



