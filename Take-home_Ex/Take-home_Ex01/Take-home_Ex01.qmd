---
title: "Take Home Exercise 1: Application of Spatial Point Patterns Analysis"

execute:
  warning: false
output:
  html_document:
    toc: true
    number_sections: true
    toc_float:
      collapsed: false
date: "`r Sys.Date()`"
---

# Project overview

In this study, we apply appropriate spatial point patterns analysis methods to discover the geographical and spatio-temporal distribution of Grab hailing services locations in Singapore and describe the spatial patterns revealed by kernel density maps.

# Installing R packages

For this exercise, I will be using the following packages:

-   sf

-   tidyverse

-   tmap

-   spatstat

-   maptools

-   raster

-   arrow

-   lubridate

-   readr (for saving transformed data sets as rds)

```{r}
pacman::p_load(sf, tidyverse, tmap, spatstat, maptools, raster, arrow, lubridate, readr)
```

# Data Import and initial data transformation

For this section, after all data sets have been transformed, they will be saved in the `rds` format for easier use in the rest of the exercise.

## Aspatial data

### Grab Posisi data

First, the data needs to be imported into RStudio. In this exercise, we will need to import all of the data in order to observe the temporal distribution.

```{r}
#| eval: false
df <- read_parquet(file="data/aspatial/GrabPosisi/part-00000.parquet")
df1 <- read_parquet(file="data/aspatial/GrabPosisi/part-00001.parquet")
df2 <- read_parquet(file="data/aspatial/GrabPosisi/part-00002.parquet")
df3 <- read_parquet(file="data/aspatial/GrabPosisi/part-00003.parquet")
df4 <- read_parquet(file="data/aspatial/GrabPosisi/part-00004.parquet")
df5 <- read_parquet(file="data/aspatial/GrabPosisi/part-00005.parquet")
df6 <- read_parquet(file="data/aspatial/GrabPosisi/part-00006.parquet")
df7 <- read_parquet(file="data/aspatial/GrabPosisi/part-00007.parquet")
df8 <- read_parquet(file="data/aspatial/GrabPosisi/part-00008.parquet")
df9 <- read_parquet(file="data/aspatial/GrabPosisi/part-00009.parquet")
```

#### Data handling: Converting the data type of *pingtimestamp* to date-time

Grab marks the date-time of each data point as a pingtimestamp. As a result, I will need to transform the data type to date-time using lubridate.

```{r}
#| eval: false
df$pingtimestamp <- as_datetime(df$pingtimestamp)
df1$pingtimestamp <- as_datetime(df1$pingtimestamp)
df2$pingtimestamp <- as_datetime(df2$pingtimestamp)
df3$pingtimestamp <- as_datetime(df3$pingtimestamp)
df4$pingtimestamp <- as_datetime(df4$pingtimestamp)
df5$pingtimestamp <- as_datetime(df5$pingtimestamp)
df6$pingtimestamp <- as_datetime(df6$pingtimestamp)
df7$pingtimestamp <- as_datetime(df7$pingtimestamp)
df8$pingtimestamp <- as_datetime(df8$pingtimestamp)
df9$pingtimestamp <- as_datetime(df9$pingtimestamp)
```

#### Data handling: Extracting trip origins

Now, we extract the trip origin locations and derive 3 new columns for weekday, starting hour and day of month into a new data frame. The origin locations are derived by grouping trips according to their `trj_id`, arranging by the date-time and filtering for the first item in each group.

```{r}
#| code-fold: true
#| eval: false


origin_df <- df %>%
  group_by(trj_id) %>%
  arrange(pingtimestamp) %>%
  filter(row_number()==1) %>%
  mutate(weekday = wday(pingtimestamp,
                        label = TRUE,
                        abbr = TRUE),
         start_hr = factor(hour(pingtimestamp)),
         day = factor(mday(pingtimestamp)))

origin_df1 <- df1 %>%
  group_by(trj_id) %>%
  arrange(pingtimestamp) %>%
  filter(row_number()==1) %>%
  mutate(weekday = wday(pingtimestamp,
                        label = TRUE,
                        abbr = TRUE),
         start_hr = factor(hour(pingtimestamp)),
         day = factor(mday(pingtimestamp)))

origin_df2 <- df2 %>%
  group_by(trj_id) %>%
  arrange(pingtimestamp) %>%
  filter(row_number()==1) %>%
  mutate(weekday = wday(pingtimestamp,
                        label = TRUE,
                        abbr = TRUE),
         start_hr = factor(hour(pingtimestamp)),
         day = factor(mday(pingtimestamp)))

origin_df3 <- df3 %>%
  group_by(trj_id) %>%
  arrange(pingtimestamp) %>%
  filter(row_number()==1) %>%
  mutate(weekday = wday(pingtimestamp,
                        label = TRUE,
                        abbr = TRUE),
         start_hr = factor(hour(pingtimestamp)),
         day = factor(mday(pingtimestamp)))

origin_df4 <- df4 %>%
  group_by(trj_id) %>%
  arrange(pingtimestamp) %>%
  filter(row_number()==1) %>%
  mutate(weekday = wday(pingtimestamp,
                        label = TRUE,
                        abbr = TRUE),
         start_hr = factor(hour(pingtimestamp)),
         day = factor(mday(pingtimestamp)))

origin_df5 <- df5 %>%
  group_by(trj_id) %>%
  arrange(pingtimestamp) %>%
  filter(row_number()==1) %>%
  mutate(weekday = wday(pingtimestamp,
                        label = TRUE,
                        abbr = TRUE),
         start_hr = factor(hour(pingtimestamp)),
         day = factor(mday(pingtimestamp)))

origin_df6 <- df6 %>%
  group_by(trj_id) %>%
  arrange(pingtimestamp) %>%
  filter(row_number()==1) %>%
  mutate(weekday = wday(pingtimestamp,
                        label = TRUE,
                        abbr = TRUE),
         start_hr = factor(hour(pingtimestamp)),
         day = factor(mday(pingtimestamp)))

origin_df7 <- df7 %>%
  group_by(trj_id) %>%
  arrange(pingtimestamp) %>%
  filter(row_number()==1) %>%
  mutate(weekday = wday(pingtimestamp,
                        label = TRUE,
                        abbr = TRUE),
         start_hr = factor(hour(pingtimestamp)),
         day = factor(mday(pingtimestamp)))

origin_df8 <- df8 %>%
  group_by(trj_id) %>%
  arrange(pingtimestamp) %>%
  filter(row_number()==1) %>%
  mutate(weekday = wday(pingtimestamp,
                        label = TRUE,
                        abbr = TRUE),
         start_hr = factor(hour(pingtimestamp)),
         day = factor(mday(pingtimestamp)))

origin_df9 <- df9 %>%
  group_by(trj_id) %>%
  arrange(pingtimestamp) %>%
  filter(row_number()==1) %>%
  mutate(weekday = wday(pingtimestamp,
                        label = TRUE,
                        abbr = TRUE),
         start_hr = factor(hour(pingtimestamp)),
         day = factor(mday(pingtimestamp)))
```

#### Data handling: Extracting destinations

To extract trip destinations, we use a similar code as above except we filter to take the nth item out of n items in a group.

```{r}
#| code-fold: true
#| eval: false


dest_df <- df %>%
  group_by(trj_id) %>%
  arrange(pingtimestamp) %>%
  filter(row_number()==n()) %>%
  mutate(weekday = wday(pingtimestamp,
                        label = TRUE,
                        abbr = TRUE),
         start_hr = factor(hour(pingtimestamp)),
         day = factor(mday(pingtimestamp)))

dest_df1 <- df1 %>%
  group_by(trj_id) %>%
  arrange(pingtimestamp) %>%
  filter(row_number()==n()) %>%
  mutate(weekday = wday(pingtimestamp,
                        label = TRUE,
                        abbr = TRUE),
         start_hr = factor(hour(pingtimestamp)),
         day = factor(mday(pingtimestamp)))

dest_df2 <- df2 %>%
  group_by(trj_id) %>%
  arrange(pingtimestamp) %>%
  filter(row_number()==n()) %>%
  mutate(weekday = wday(pingtimestamp,
                        label = TRUE,
                        abbr = TRUE),
         start_hr = factor(hour(pingtimestamp)),
         day = factor(mday(pingtimestamp)))

dest_df3 <- df3 %>%
  group_by(trj_id) %>%
  arrange(pingtimestamp) %>%
  filter(row_number()==n()) %>%
  mutate(weekday = wday(pingtimestamp,
                        label = TRUE,
                        abbr = TRUE),
         start_hr = factor(hour(pingtimestamp)),
         day = factor(mday(pingtimestamp)))

dest_df4 <- df4 %>%
  group_by(trj_id) %>%
  arrange(pingtimestamp) %>%
  filter(row_number()==n()) %>%
  mutate(weekday = wday(pingtimestamp,
                        label = TRUE,
                        abbr = TRUE),
         start_hr = factor(hour(pingtimestamp)),
         day = factor(mday(pingtimestamp)))

dest_df5 <- df5 %>%
  group_by(trj_id) %>%
  arrange(pingtimestamp) %>%
  filter(row_number()==n()) %>%
  mutate(weekday = wday(pingtimestamp,
                        label = TRUE,
                        abbr = TRUE),
         start_hr = factor(hour(pingtimestamp)),
         day = factor(mday(pingtimestamp)))

dest_df6 <- df6 %>%
  group_by(trj_id) %>%
  arrange(pingtimestamp) %>%
  filter(row_number()==n()) %>%
  mutate(weekday = wday(pingtimestamp,
                        label = TRUE,
                        abbr = TRUE),
         start_hr = factor(hour(pingtimestamp)),
         day = factor(mday(pingtimestamp)))

dest_df7 <- df7 %>%
  group_by(trj_id) %>%
  arrange(pingtimestamp) %>%
  filter(row_number()==n()) %>%
  mutate(weekday = wday(pingtimestamp,
                        label = TRUE,
                        abbr = TRUE),
         start_hr = factor(hour(pingtimestamp)),
         day = factor(mday(pingtimestamp)))

dest_df8 <- df8 %>%
  group_by(trj_id) %>%
  arrange(pingtimestamp) %>%
  filter(row_number()==n()) %>%
  mutate(weekday = wday(pingtimestamp,
                        label = TRUE,
                        abbr = TRUE),
         start_hr = factor(hour(pingtimestamp)),
         day = factor(mday(pingtimestamp)))

dest_df9 <- df9 %>%
  group_by(trj_id) %>%
  arrange(pingtimestamp) %>%
  filter(row_number()==n()) %>%
  mutate(weekday = wday(pingtimestamp,
                        label = TRUE,
                        abbr = TRUE),
         start_hr = factor(hour(pingtimestamp)),
         day = factor(mday(pingtimestamp)))
```

#### Combining into one data frame

For easier handling, I am going to combine the data frames into one `origin` data frame and one `destination` data frame.

```{r}
#| eval: false

origin_all <- origin_df %>%
  full_join(origin_df1) %>%
  full_join(origin_df2) %>%
  full_join(origin_df3) %>%
  full_join(origin_df4) %>%
  full_join(origin_df5) %>%
  full_join(origin_df6) %>%
  full_join(origin_df7) %>%
  full_join(origin_df8) %>%
  full_join(origin_df9)

```

```{r}
#| eval: false

dest_all <- dest_df %>%
  full_join(dest_df1) %>%
  full_join(dest_df2) %>%
  full_join(dest_df3) %>%
  full_join(dest_df4) %>%
  full_join(dest_df5) %>%
  full_join(dest_df6) %>%
  full_join(dest_df7) %>%
  full_join(dest_df8) %>%
  full_join(dest_df9)
```

#### Writing data as rds

With the data transformation done, we can now write it out as an rds for future use.

```{r}
#| eval: false

write_rds(origin_all, "data/rds/grab_origins.rds")
write_rds(dest_all, "data/rds/grab_dest.rds")
```

## Geospatial data

### Singapore Coastal outline (excluding islands)

This layer is derived from the Master Plan 2019 Subzone Boundary (No Sea) from data.gov. First, it needs to be imported into rstudio using *st_read()*

```{r}
#| eval: false

mpsz_sf <- st_read(dsn = "data/geospatial", 
                layer = "MPSZ-2019")
```

From the summary, it can be seen that the layer is projected to WGS84. To continue, there is the need to reproject the polygons to the correct CRS SVY21.

```{r}
#| eval: false

mpsz3414_sf <- st_transform(mpsz_sf, 3414)
```

Now, we can plot the map and view the data.

```{r}
#| eval: false
plot(mpsz3414_sf["SUBZONE_N"])
```

There are some islands in the map that lack bridges for Grab drivers to reach, such as Coney Island. However, there are other relevant islands such as Sentosa that need to be kept.

From research, Grab drivers can be observed to be able to enter [Sentosa](https://www.grab.com/sg/sentosaentry/) and [Jurong Island](https://www.firstlane.com.sg/grab-jurong-island-pass/) to pick up and drop off passengers at the current moment. However, the Jurong Island polygon in `mpsz3414_sf` is combined with another island Bukom. Furthermore, Grab drivers are only allowed onto the island if they have a security pass, resulting in few drivers entering and exiting the island. Therefore, I am choosing to remove Jurong Island and Bukom from the map.

Hence, the islands that need to be excluded from the map are:

-   Coney Island

-   Southern Group

-   North-Eastern islands (including [Pulau Ubin](https://wansubinjournal.blogspot.com/p/ubin-map.html): Grab drivers can only pick up and drop off passengers at the ferry terminal)

-   Sudong

-   Semakau

-   Jurong Island and Bukom

To remove these, I've chosen to filter them out by name. This is because Sentosa and Jurong Island are also labelled as "islands" and would otherwise be caught.

```{r}
#| eval: false
main_island <- mpsz3414_sf %>%
              filter(SUBZONE_N !="CONEY ISLAND") %>%
              filter(SUBZONE_N != "NORTH-EASTERN ISLANDS") %>%
              filter(SUBZONE_N != "SOUTHERN GROUP") %>%
              filter(SUBZONE_N != "SUDONG") %>%
              filter(SUBZONE_N != "SEMAKAU") %>%
              filter(SUBZONE_N != "SUDONG") %>%
              filter(SUBZONE_N != "JURONG ISLAND AND BUKOM")

plot(main_island["SUBZONE_N"])
```

Now, we can use *st_union* to get the outline of Singapore.

```{r}
#| eval: false

plot(st_union(main_island))
```

#### Writing data as rds

With this, we can now save the data in the rds format.

```{r}
#| eval: false

write_rds(main_island, "data/rds/islandOutline.rds")
```

### Singapore road network

In order to conduct Network Kernel Density Estimation (NKDE), we will need a road network to map points onto. For Singapore's road network, we can get data from OpenStreetMap via [Geofabrik](https://download.geofabrik.de/). From the documentation that comes with the download, we know that the road network is found in the `gis_osm_roads_free_1` shape file.

```{r}
#| eval: false

roads_all <- st_read(dsn = "data/geospatial/openstreetmap", 
                layer = "gis_osm_roads_free_1")
```

This data is also not projected to SVY21, which is something we will have to fix.

```{r}
#| eval: false

roads_all <- st_transform(roads_all, 3414)
```

One issue currently is that the data includes all roads from [Singapore, Malaysia and Brunei](https://download.geofabrik.de/asia.html). We only want the road network for Singapore. In order to extract this, we can use *st_intersection* to filter for roads within Singapore based on the `CoastalOutline` layer (as imported from rds)

```{r}
#| eval: false

sg_roads <- st_intersection(roads_all, CoastalOutline)
```

Due to the size of the data, we will later be narrowing the scope of our investigation for NKDE to certain subzones. For now, I will save the current road network into an rds.

```{r}
#| eval: false

write_rds(sg_roads, "data/rds/sgroads.rds")
```

# Final import of data

```{r}
origin_all_df <- read_rds("data/rds/grab_origins.rds")
dest_all_df <- read_rds("data/rds/grab_dest.rds")
CoastalOutline <- read_rds("data/rds/islandOutline.rds")
sg_roads <- read_rds("data/rds/sgroads.rds")
```

# Data wrangling: origins

## Analysis of origins

First, lets look at the distribution of origins over time using `ggplot`.

```{r}
ggplot(data = origin_all_df,
       aes(x=weekday)) +
geom_bar()
```

As seen above, the data is evenly distributed across all days of the week.

### ppp object transformation

In order to conduct Kernel Density Estimation (KDE), we need to transform our layers into a ppp object. Before we begin that process, we will need to transform `origin_all_df` into an sf object using *st_as_sf()*.

::: callout-important
For the "crs" argument of *st_as_sf()*, we need to provide it with a geodetic CRS and not a projected CRS. To transform the CRS, we can pipe the output into an *st_transform()* argument.
:::

```{r}
origins_sf <- st_as_sf(origin_all_df, 
                       coords = c("rawlng", "rawlat"),
                       crs=4326) %>%
  st_transform(crs = 3414)
```

Now, we can transform all relevant data frames into a ppp object (via transforming to Spatial/\*, SpatialPoints and then ppp objects), which we can inspect using the *summary* function.

```{r}
origin_spatial <- as_Spatial(origins_sf)
origin_sp <- as(origin_spatial, "SpatialPoints")
origin_ppp <- as(origin_sp, "ppp")

summary(origin_ppp)
```

### Duplicate data handling

Now, we need to check for duplicated data.

```{r}
any(duplicated(origin_ppp))
```

If we want to know how many locations have more than one point event, we can use the following:

```{r}
sum(multiplicity(origin_ppp) > 1)
```

To handle this data, we can employ **jittering** so that points do not occupy the exact same space.

```{r}
origins_ppp_jit <- rjitter(origin_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)
```

Now we can check again for duplicate points.

```{r}
any(duplicated(origins_ppp_jit))
```

### Creating owin object

Next, we need to confine the analysis with a geographical area like Singapore boundary. If a study area is not defined and confined, the data points will assume it can occur within blank spaces (because technically it will spread out at random).

```{r}
sg_owin <- as.owin(CoastalOutline)
plot(sg_owin)
```
```{r}
summary(sg_owin)
```

With that, we can finally plot the point data onto the map.

```{r}
originSG = origins_ppp_jit[sg_owin]

plot(originSG)
```

# Kernel Density Estimation: origins

## Rescaling values

Before we can conduct KDE analysis, we first need to rescale the unit of measurement in `originSG` from metres (the unit of measurement in SVY21) to kilometres (to avoid small numbers).

```{r}
originSG_km <- rescale(originSG, 1000, "km")
```

## Working with different automatic bandwidth selection methods

There are 4 different automatic bandwidth selection method that we can choose: *bw.diggle, bw.CvL, bw.scott* and *bw.ppl*. We can plot all of them to see which is the best fitting method for the data that we have.

```{r}
kde_origins_dig <- density(originSG_km,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian") 

plot(kde_origins_dig, main = "bw.diggle")
```

```{r}
#| eval: false

kde_origins_dig <- density(originSG_km,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian") 

kde_origins_ppl <- density(originSG_km, 
                               sigma=bw.ppl, 
                               edge=TRUE,
                               kernel="gaussian")
par(mfrow=c(1,2))
plot(kde_origins_dig, main = "bw.diggle")
plot(kde_origins_ppl, main = "bw.ppl")
```

```{r}
#| eval: false

kde_origins_cvl <- density(originSG_km,
                              sigma=bw.CvL,
                              edge=TRUE,
                            kernel="gaussian") 
```

```{r}
#| eval: false

kde_origins_scott <- density(originSG_km,
                              sigma=bw.scott,
                              edge=TRUE,
                            kernel="gaussian") 
```

```{r}
#| eval: false

kde_origins_ppl <- density(originSG_km,
                              sigma=bw.ppl,
                              edge=TRUE,
                            kernel="gaussian") 
```

```{r}
#| eval: false

par(mfrow=c(1,2))
plot(kde_origins_dig)
plot(kde_origins_cvl)
plot(kde_origins_scott)
plot(kde_origins_ppl)
```
